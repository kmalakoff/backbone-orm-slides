
<section>
  <h1>Design Goals</h1>
  <h3>AKA: biting the bullet</h3>
</section>
<section>
  <h3>MongoDB inspired query langauge</h3>
  <h3 class="fragment">Rails / Django style query chaining</h3>
  <h3 class="fragment">Backbone.js Models and Collections</h3>
</section>
<section>
  <h2>Node-y callbacks everywhere</h2>
  <div class="fragment">
    <h2>That consistent API</h2>
    <h4>ACross client and server</h4>
  </div>
  <div class="fragment">
    <h2>Trivial REST API generation</h2>
    <h4>With super flexible templates</h4>
  </div>
</section>
<!--section-->
<!--  h1 The Basics-->
<!--  .left-->
<!--    p Provide an intuitive query langauge: inspired by the MongoDB gold standard-->
<!--    p Must be Node-y: callback-based queries and promise-based cursors - we got'em!-->
<!--    p Low learning curve: consistent API across Browser and Node.js-->
<!--    p Backbone.js Model and Collection compatible with built-in relationships: we use Knockback.js-->
<!--    p Trivial JSON API generation: raw JSON or DSL to customize-->
<section>
  <h1>Above and Beyond</h1>
  <!--.fragment.left-->
  <!--  p URL-based query syntax: debug JSON queries on the search bar-->
  <!--  p Both JSON and Model interfaces for JSON-only APIs when a full relation, model-based ORM is overkill-->
  <!--  p Batch-based, browser-side processing of server models: wanna generate a report in the Browser?-->
  <!--  p Node.js-based stream support: wanna stream to JSON from Postgres?-->
  <!--  p Relationships in MongoDB: well, it came for free-->
  <!--  p In Memory store: great for config file queries-->
</section>