
<section>
  <h1>Why?</h1>
  <h3>Node has like a bazillion of them</h3>
</section>
<section>
  <h1>Yeah, with like a bazillion APIs</h1>
  <h3 class="fragment">and</h3>
</section>
<section>
  <h3>There's something</h3>
  <h1>Missing</h1>
</section>
<section>
  <h2>Node ORM</h2>
  <h1 class="fragment zoom-in">What goes in between?</h1>
  <h2>Browser MV*</h2>
</section>
<!--section-->
<!--  h1 Why not?-->
<!--  p ORMs must be easy, right?-->
<!--  p Almost every language has got one or more!-->
<!---->
<!--section-->
<!--  h1 Seriously-->
<!--  p Node.js and browser MVC/MVVM frameworks are awesome inventions that really accelerate development, but there's a problem...-->
<!--section-->
<!--  h2 They need to talk to each other-->
<!--section-->
<!--  p But without a standard API across browser and server, the "JavaScript Everywhere" promise breaks a little.-->
<!--  h4 That's why there is Meteor-->
<!--  h4 That's why there is Backbone-ORM-->
<section>
  <h2>"JavaScript Everywhere"</h2>
  <h3>Let's do that</h3>
  <h3>With a<strong>&nbsp;consistent&nbsp;</strong>API</h3>
</section>
<section>
  <h1>Backbone-ORM</h1>
  <h4>Server</h4>
  <pre><code class="language-coffeescript">
      class Project extends Backbone.Model
        urlRoot: 'mongodb://localhost:27017/projects'
        sync: require('backbone-mongo').sync(Project)
        
      # Find all items with is_active = true
      Project.find {is_active: true}, (err, projects) ->
      </code></pre>
  <div class="fragment">
    <h4>Client</h4>
    <pre><code class="language-coffeescript">
        class Project extends Backbone.Model
          urlRoot: '/projects'
          sync: require('backbone-http').sync(Project)
          
        # Find all items with is_active = true
        Project.find {is_active: true}, (err, projects) ->
        </code></pre>
    <div></div>
  </div>
</section>